var controls;
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth/window.innerHeight,
    0.1,
    100000
);


var cameraSpeedFactor = .1

var nodeGeometry = new THREE.SphereGeometry( .2, .2, .2 );
var color = Math.random()*16777215;
var nodeMaterial = new THREE.MeshBasicMaterial( { color: 0x00cc00 } );
var lineMaterial = new THREE.LineBasicMaterial( { color: 0x00f0ff});
var viewframeGridMaterial = new THREE.LineBasicMaterial( { color: 0xff6600});
var drawNodes = false;
var animatedLineSpacing = 5;
var wireframeResolutionFactor = 5;

/*
    Terrain rendering configuration
*/

var nodeSpacingFactor = 2
var heightOffset = -1800
var heightFactor = .5

// Initialize viewframe

var viewframeSize = {
    "east": 900, //easting
    "north":1000, //northing
}



/*
    This is some elevation data generated by terrain.py -- currently we just
    slam against the GeoGratis API but eventually we want to store the full
    elevation data locally
*/

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
var viewport = document.getElementById("viewport")
viewport.appendChild( renderer.domElement );


/* -------------------------------------------------------
    Terrain drawing
------------------------------------------------------- */ 
function placeNodeAtSpot(x, y, z, material) {
    if (!drawNodes) { return }
    var dotShape = new THREE.Mesh( nodeGeometry, material);
    dotShape.position.set(x, y, z);
    scene.add( dotShape );
}
function drawPlot(data, material) {
    var currentDisplayGeometry = new THREE.SphereGeometry(1,1,1);
    var currentDisplayMaterial = material;
    var currentDisplayTerrain = new THREE.Mesh( currentDisplayGeometry, currentDisplayMaterial);
    currentDisplayTerrain.position.set(0,0,0);
    

    for (var easting in data) {
        for (var northing in data[easting]) {


            /* -------
                Draw single elevation points
            ------- */

            placeNodeAtSpot(
                easting * nodeSpacingFactor, 
                (data[easting][northing] + heightOffset) * heightFactor,
                northing * nodeSpacingFactor,
                this.nodeMaterial
            ) 

    
            /* ------- 
            Draw north/south lines
            ------- */ 

            if (northing > 1 && easting % wireframeResolutionFactor == 0) {
                var lineGeometry = new THREE.Geometry();
    
                lineGeometry.vertices.push(
                    new THREE.Vector3(
                        easting * nodeSpacingFactor,
                        (data[easting][northing] + heightOffset) * heightFactor,
                        northing * nodeSpacingFactor
                    )
                )
    
                lineGeometry.vertices.push(
                    new THREE.Vector3(
                        easting * nodeSpacingFactor,
                        (data[easting][northing-1] + heightOffset) * heightFactor,
                        (northing - 1) * nodeSpacingFactor
                    )
                )
                var line = new THREE.Line(lineGeometry, material);
                currentDisplayTerrain.add(line);
            }
            if (easting > 1 && northing % wireframeResolutionFactor  == 0) {
                lineGeometry = new THREE.Geometry();

                lineGeometry.vertices.push(
                    new THREE.Vector3(
                        easting * nodeSpacingFactor,
                        (data[easting][northing] + heightOffset) * heightFactor,
                        northing * nodeSpacingFactor
                    )
                )
                lineGeometry.vertices.push(
                    new THREE.Vector3(
                        (easting - 1) * nodeSpacingFactor,
                        (data[easting-1][northing] + heightOffset) * heightFactor,
                        northing * nodeSpacingFactor
                    )
                )
                var line = new THREE.Line(lineGeometry, material);
                currentDisplayTerrain.add(line);

            }
        }
    }
    currentDisplayTerrain.name = "latest-terrain";
    scene.add(currentDisplayTerrain);
}

/* -------------------------------------------------------
    Camera position helpers
------------------------------------------------------- */ 

var cameraPosition = {
    mainView: function() {
        camera.position.x = 517.1996170854956;
        camera.position.y = 141.19051786019642;
        camera.position.z = 280.1864751286993;
        camera.rotation.x = -0.4667756867117924;
        camera.rotation.y = 1.0255139857293059;
        camera.rotation.z = 0.4068057224000214;
    },
    showcaseView: function() {
        camera.position.x = 826.3669282284727;
        camera.position.y = -221.4827348648144;
        camera.position.z = -31.116286932030782;
        camera.rotation.x = 1.9574056341510448;
        camera.rotation.y = 1.1521917983810586;
        camera.rotation.z = -1.9899589029
    },
    animationView: function() {
        camera.position.x = 220.7605568238203;
        camera.position.y = 10.507774462181791;
        camera.position.z = -921.8726416009445;
        camera.rotation.x = -3.130194853884681;
        camera.rotation.y = 0.23502878690842438;
        camera.rotation.z = 3.138938328205593;
    }
}



/* -------------------------------------------------------
    Camera Animation
------------------------------------------------------- */ 
var cameraPadding = 5;

var mapEastWidth = yamData.length;
var mapNorthWidth = yamData[0].length;
var eastMidpoint = (mapEastWidth/2) * nodeSpacingFactor;
var northMidpoint = (mapNorthWidth/2) * nodeSpacingFactor;
var cameraSpeed = nodeSpacingFactor * cameraSpeedFactor;
var cameraOriginWidth = eastMidpoint + cameraPadding;

if (northMidpoint > eastMidpoint) {
    cameraOriginWidth = northMidpoint + cameraPadding;
}

cameraOriginWidth = 10;

var cameraOriginGeometry = new THREE.SphereGeometry(
    cameraOriginWidth,
    32,
    32
);
var cameraOriginMaterial = new THREE.MeshBasicMaterial( {color: 0xffff00} );
var cameraOrigin = new THREE.Mesh( cameraOriginGeometry, cameraOriginMaterial);
cameraOrigin.position.set(
    eastMidpoint,
    0,
    northMidpoint 
);
cameraOrigin.add(camera);
cameraOrigin.visible = false;
camera.lookAt(cameraOrigin);
scene.add(cameraOrigin);


function animateCamera() {
//    camera.position.x= camera.position.x + cameraSpeed; // Pan/track
    cameraOrigin.rotateOnAxis(
        new THREE.Vector3(0, 1, 0),
        Math.PI/128
    )
}


/* -------------------------------------------------------
    Terrain animation
------------------------------------------------------- */ 


function createViewframe(frameSize) {
    var frame = {
        "size": frameSize,
        "pointGrid": [],
        "rootNode": new THREE.Mesh( new THREE.SphereGeometry(1,1,1), new THREE.MeshBasicMaterial()),
        "geometry": [],
        "position": {
            "east":frameSize.east,
            "north":frameSize.north
        }

    }

//    frame.rootNode.visible = false;

    for (var east = 0; east < frameSize.east; east++) {
        var eastScanLinePoints = []
        for (var north = 0; north < frameSize.north; north++) {
           eastScanLinePoints.push(
               new THREE.Vector3(
                    east * nodeSpacingFactor,
                    500, //initialize all points at an arbitrary height
                    north * nodeSpacingFactor
               )
           );
        }
        frame.pointGrid.push(eastScanLinePoints);

        if (east % animatedLineSpacing == 0) {
            var eastScanLineGeometry = new THREE.Geometry();
            eastScanLineGeometry.vertices = eastScanLinePoints;
            var eastScanLine = new THREE.Line(eastScanLineGeometry, new THREE.MeshBasicMaterial({color: 0xff6600}));
            frame.geometry.push(eastScanLine)
            frame.rootNode.add(eastScanLine)
         }
    }
    return frame;
}

function stepViewFrameData(frame) {
    frame.pointGrid.push(frame.pointGrid.shift());

    frame.position.east++;


    frame.pointGrid.forEach(function updateScanLine(eastScanLine, eastIndex) {
        eastScanLine.forEach(function updatePoint(point, northIndex) {
            frame.pointGrid[eastIndex][northIndex].x = eastIndex * nodeSpacingFactor;
            frame.pointGrid[eastIndex][northIndex].z = northIndex * nodeSpacingFactor;
        })
    });

    frame.geometry.forEach(function recalculateLine(line, index) {
        line.geometry.dynamic = true;
        line.geometry.verticesNeedUpdate = true;
    })
}

function initializeGroundAnimation(mapData, frame) {
    frame.pointGrid.forEach(function setScanLine(eastScanLine, east) {
        eastScanLine.forEach(function setPointValue(height, north) {
            frame.pointGrid[east][north].y = (mapData[east][north] + heightOffset) * heightFactor
        })
    })
    stepViewFrameData(frame)
}

function animateTopology(frame) {
    stepViewFrameData(frame)
}


/* -------------------------------------------------------
    Mouse & Touch camera controls
------------------------------------------------------- */ 

controls = new THREE.OrbitControls( camera );
controls.damping = 0.2;
controls.addEventListener( 'change', render );


/* -------------------------------------------------------
    Main drawing logic
------------------------------------------------------- */ 

cameraPosition.animationView();

var render = function () {
	requestAnimationFrame( render );
	renderer.render(scene, camera);
//    animateCamera();
    animateTopology(scanningView);
};

var scanningView = createViewframe(viewframeSize)
scene.add(scanningView.rootNode)
initializeGroundAnimation(yamData, scanningView)

render();

/* -------------------------------------------------------
    debug junk
------------------------------------------------------- */ 
var logger = document.getElementById("log");
var debugLog = function(text) {
    logger.value += text + "\n";
}
var camDump = function () {
    logger.value = "";
    debugLog("camera.position.x = " + camera.position.x + ";")
    debugLog("camera.position.y = " + camera.position.y + ";")
    debugLog("camera.position.z = " + camera.position.z + ";")
    debugLog("camera.rotation.x = " + camera.rotation.x + ";")
    debugLog("camera.rotation.y = " + camera.rotation.y + ";")
    debugLog("camera.rotation.z = " + camera.rotation.z + ";")
    console.log(logger.value);
}

//drawPlot(yamData, lineMaterial);
